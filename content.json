{"pages":[{"title":"About","text":"","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Logitech G29 Pedal, Shifter 를 PC 와 직접 연결하기","text":"글을 쓰게 된 계기G29 를 사용하던 도중 Thrustmaster T300RS 제품을 할인한다는 소식을 들었다. 30만원도 안되는 가격에 새 제품을 구매하게 되었다. 그러나 T300RS 의 기본 페달은 브레이크가 너무 물렁하고 클러치가 없다. 그래서 기존에 사용하던 Logitech Shifter 와 G29 Pedal 을 같이 사용 할 순 없을까? 하는 마음에 구글링을 해 보았더니 국내 자료는 잘 찾을 수가 없었고, 해외 자료는 꽤 존재하였다. 블로그를 한동안 안했지만, 이 기회를 발판 삼아 다시 시작하며, 한국어로의 번역 겸 경험기로 글을 남기기로 결정하여 이렇게 글을 쓰게 되었다. 준비물 아두이노에 대한 기초적인 사용 방법, 약간의 전기 지식 Arduino Leonardo 등 ATmega32u4 사용하는 보드 (사용하는 Joystic 모듈에서 지원하지 않음) 빵판 (Bread Board) DB9 암 / 수 모듈 (구하기 힘들다면 아래 제품으로 대체 가능) 핀 헤더, 납땜 도구 (쉬프터 사용시) 점퍼 케이블 (G29 페달 사용시) 참고 자료AMSTUDIO 검색을 하면 유튜브 영상이 많이 나오는데, 대부분 이 사이트가 출처이다. Logitech Shifter가장 먼저 연결한것은 로지텍 쉬프터이다. 이미 T300RS 를 구매할 때 기본적으로 페달이 있기 때문에 쉬프터와 연결이 되는지를 테스트 하고 싶었다. 이 영상을 보고 인터넷에서 DB9 - USB 연결 잭을 구매하여 PC 와 연결해 보았지만, 이것으로는 내가 원하는 쉬프터의 작동을 할 수가 없었다… 실패 그래서 기왕 산 DB9 를 분해하려고 했지만 제대로 분해가 되지 않아서 영상과 같이 납땜을 할 수가 없었다. 쉬프터의 DB9 소켓에는 점퍼케이블이 너무 헐거워서 제대로 꼽히지가 않았다. 조금 더 두꺼운게 필요했는데, 마침 집에 남아있던 핀헤더를 연결해보니 아주 완벽하게 딱 맞진 않지만 적당히 잘 연결된 느낌이 들어서 핀헤더에 납땜을 하였다. 유튜브 영상에 나온 회로도를 그대로 아두이노와 연결한다. 사실 위 회로도에서 중요한것은 DB9 쪽이다. 아두이노쪽은 다른곳에 연결하더라도, 추후 코드에서 포트 번호 수정으로 쉽게 해결이 가능하기 때문이다. 회로도대로 연결을 성공하였다면 코드를 받아야 한다. SHIFTERS 직접다운로드 링크를 걸 수도 있지만, 유튜브 영상에서도 이쪽으로 링크를 걸고 있기 때문에 나도 이쪽 링크를 걸었다. 가장 하단의 DIY LOGITECH USB SHIFTER ADAPTER 부분의 Download 를 눌러 받는다. 해당 코드를 열어보면 Joystic.h 라이브러리를 필요로 하고 있기 때문에 해당 라이브러리를 Arduino IDE 에 추가해야 한다. (방법은 영상에도 나온다) MHeironimus/ArduinoJoystickLibrary 이후 컴파일 체크 후 업로드를 하여 제어판 - 장치 및 프린터 - Arduino Leonardo 를 찾는다. 우클릭을 하면 게임 컨트롤러 설정 을 누르고 속성 버튼을 눌러 기어가 정상적으로 동작하는지 체크해본다. 나는 1, 2, 5, 6, R 기어는 정상적으로 나타나지만 3, 4 단이 정상적으로 들어가지 않았다. X 축의 저항값이 제대로 잡히지 않는것 같아서 디버깅 환경을 만들어서 테스트를 해보았다. Serial 포트를 열고, Serial 로그에 X 축 값이 몇으로 잡히는지 테스트 하는 코드를 추가하였다. 1234void setup() { Serial.begin(9600); // 이 라인 추가 // ...} 1234int x=analogRead(0); // X axisint y=analogRead(2); // Y axisSerial.println(x); // 이 라인 추가 이후 아두이노의 시리얼 모니터를 보며 쉬프터를 움직여보니 3, 4 단을 넣을 경우 약 540 정도의 값이 찍히고 있었다. 코드에서는 5, 6 단으로 인식하는 수치가 500정도로 설정이 되어있었고, 해당 값을 630 정도로 수정했다. 1#define HS_XAXIS_56 630 후진 기어가 누른채로 6단을 넣을 때가 아니라 누르기만 해도 들어가는 버그와, 쉬프터를 좌측 (1단 2단 넣기위한 방향)으로 밀면 아날로그 핸드브레이크 모드로 동작하도록 하는 코드를 추가하였다. 기능들을 추가하며 전체적으로 코드 리포메팅을 하였기 때문에 변화가 많아 보일 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158//Logitech Driving Force Shifter USB Adapter//By Armandoiglesias 2018//Based on Jason Duncan functionreturnfunction Project//Video tutorial https://www.youtube.com/watch?v=dLpWEu8kCec//Use Arduino Leonardo//Install Joystick Library//Attribution-NonCommercial-NoDerivatives 4.0 International#include &lt;Joystick.h&gt;// Create the JoystickJoystick_ Joystick;// H-shifter mode analog axis thresholds#define HS_XAXIS_12 400#define HS_XAXIS_56 500#define HS_YAXIS_135 800#define HS_YAXIS_246 300// Sequential shifter mode analog axis thresholds#define SS_UPSHIFT_BEGIN 670#define SS_UPSHIFT_END 600#define SS_DOWNSHIFT_BEGIN 430#define SS_DOWNSHIFT_END 500// Handbrake mode analog axis limits#define HB_MAXIMUM 530#define HB_MINIMUM 400#define HB_RANGE (HB_MAXIMUM - HB_MINIMUM)// Digital inputs definitions#define DI_REVERSE 1#define DI_MODE 3#define DI_RED_CENTERRIGHT 4#define DI_RED_CENTERLEFT 5#define DI_RED_RIGHT 6#define DI_RED_LEFT 7#define DI_BLACK_TOP 8#define DI_BLACK_RIGHT 9#define DI_BLACK_LEFT 10#define DI_BLACK_BOTTOM 11#define DI_DPAD_RIGHT 12#define DI_DPAD_LEFT 13#define DI_DPAD_BOTTOM 14#define DI_DPAD_TOP 15// Shifter state#define DOWN_SHIFT -1#define NO_SHIFT 0#define UP_SHIFT 1// Shifter mode#define SHIFTER_MODE 0#define HANDBRAKE_MODE 1// LED blink counterint led = 0;// Shifter stateint shift = NO_SHIFT;// Handbrake modeint mode = SHIFTER_MODE;int b[16];int gear = 0; // Default value is neutral// Constant that maps the phyical pin to the joystick button.//const int pinToButtonMap = 9;void setup(){ // G29 shifter analog inputs configuration pinMode(A0, INPUT_PULLUP); // X axis pinMode(A2, INPUT_PULLUP); // Y axis pinMode(2, INPUT); for (int i = 0; i &lt; 16; i++) b[i] = 0; b[DI_MODE] = 0; // Initialize Joystick Library Joystick.begin();}// Last state of the buttonint lastButtonState = 0;void loop(){ int x = analogRead(0); // X axis int y = analogRead(2); // Y axis int _isreverse = digitalRead(2); int _gear_ = 0; if (mode == HANDBRAKE_MODE) { int mapped = map(x, 300, 500, 0, 1024); Joystick.setThrottle(mapped); } else { if (_isreverse == 1) { b[DI_REVERSE] = 1; } else { if (b[DI_MODE] == 0) // H-shifter mode? { if (x &lt; HS_XAXIS_12) // Shifter on the left? { if (y &gt; HS_YAXIS_135) _gear_ = 1; // 1st gear if (y &lt; HS_YAXIS_246) _gear_ = 2; // 2nd gear } else if (x &gt; HS_XAXIS_56) // Shifter on the right? { if (y &gt; HS_YAXIS_135) _gear_ = 5; // 5th gear if (y &lt; HS_YAXIS_246) _gear_ = 6; // 6th gear } else // Shifter is in the middle { if (y &gt; HS_YAXIS_135) _gear_ = 3; // 3rd gear if (y &lt; HS_YAXIS_246) _gear_ = 4; // 4th gear } } } if (gear == 6 &amp;&amp; _isreverse == 1) // Reverse gear is allowed only on 6th gear position { b[DI_REVERSE] = 1; _gear_ = 8; } if (_gear_ != gear) { gear = _gear_; desactivar(); Joystick.setButton(gear - 1, HIGH); } } delay(50);}void desactivar(){ // Depress virtual button for current gear for (int i = 0; i &lt;= 10; i++) Joystick.setButton(i, LOW);} G29 Pedal 페달도 위 쉬프터 방법과 비슷하다. 다만 페달의 경우 점퍼케이블과 연결이 가능해서 납땜은 필요하지 않다. 영상을 참고해 1~4, 6, 9 번 핀을 연결한다. 한가지 아두이노 보드에 페달과 쉬프터를 모두 연결 할 예정이므로, 나는 2, 3, 4 번 포트를 각각 A3, A4, A5 에 연결하였다. 이후 아래 코드를 통해 컴파일하여 업로드를 하고, 아까와 같이 잘 동작하는지 확인을 해 보았는데 모두 정상적으로 동작하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//Logitech Driving Force Shifter USB Adapter//By Armandoiglesias 2018//Based on Jason Duncan functionreturnfunction Project//Video tutorial https://www.youtube.com/watch?v=dLpWEu8kCec//Use Arduino Leonardo//Install Joystick Library//Attribution-NonCommercial-NoDerivatives 4.0 International#include &lt;Joystick.h&gt;// Create the JoystickJoystick_ Joystick;// H-shifter mode analog axis thresholds#define HS_XAXIS_12 400#define HS_XAXIS_56 500#define HS_YAXIS_135 800#define HS_YAXIS_246 300// Sequential shifter mode analog axis thresholds#define SS_UPSHIFT_BEGIN 670#define SS_UPSHIFT_END 600#define SS_DOWNSHIFT_BEGIN 430#define SS_DOWNSHIFT_END 500// Handbrake mode analog axis limits#define HB_MAXIMUM 530#define HB_MINIMUM 400#define HB_RANGE (HB_MAXIMUM - HB_MINIMUM)// Digital inputs definitions#define DI_REVERSE 1#define DI_MODE 3#define DI_RED_CENTERRIGHT 4#define DI_RED_CENTERLEFT 5#define DI_RED_RIGHT 6#define DI_RED_LEFT 7#define DI_BLACK_TOP 8#define DI_BLACK_RIGHT 9#define DI_BLACK_LEFT 10#define DI_BLACK_BOTTOM 11#define DI_DPAD_RIGHT 12#define DI_DPAD_LEFT 13#define DI_DPAD_BOTTOM 14#define DI_DPAD_TOP 15// Shifter state#define DOWN_SHIFT -1#define NO_SHIFT 0#define UP_SHIFT 1// Shifter mode#define SHIFTER_MODE 0#define HANDBRAKE_MODE 1// LED blink counterint led = 0;// Shifter stateint shift = NO_SHIFT;// Handbrake modeint mode = SHIFTER_MODE;int b[16];int gear = 0; // Default value is neutral// Constant that maps the phyical pin to the joystick button.//const int pinToButtonMap = 9;void setup(){ // For Debugging code // Serial.begin(9600); // G29 shifter analog inputs configuration pinMode(A0, INPUT_PULLUP); // X axis pinMode(A2, INPUT_PULLUP); // Y axis pinMode(2, INPUT); // Logitech G29 Pedal Input pinMode(A3, INPUT_PULLUP); // Accelerator axis pinMode(A4, INPUT_PULLUP); // Brake axis pinMode(A5, INPUT_PULLUP); // Clutch axis for (int i = 0; i &lt; 16; i++) b[i] = 0; b[DI_MODE] = 0; // Initialize Joystick Library Joystick.begin();}// Last state of the buttonint lastButtonState = 0;void loop(){ int x = analogRead(0); // X axis int y = analogRead(2); // Y axis int ac = analogRead(3); // Accelerator axis int br = analogRead(4); // Brake axis int cl = analogRead(5); // Clutch axis // Serial.print(ac); // Serial.print(&quot; &quot;); // Serial.print(br); // Serial.print(&quot; &quot;); // Serial.println(cl); int mappedAc = map(ac, 100, 925, 0, 1024); int mappedBr = map(br, 400, 935, 0, 1024); int mappedCl = map(cl, 135, 950, 0, 1024); Joystick.setXAxis(mappedAc); Joystick.setYAxis(mappedBr); Joystick.setZAxis(mappedCl); int _isreverse = digitalRead(2); int _gear_ = 0; if (mode == HANDBRAKE_MODE) { int mapped = map(x, 300, 500, 0, 1024); Joystick.setThrottle(mapped); } else { if (_isreverse == 1) { b[DI_REVERSE] = 1; } else { if (b[DI_MODE] == 0) // H-shifter mode? { if (x &lt; HS_XAXIS_12) // Shifter on the left? { if (y &gt; HS_YAXIS_135) _gear_ = 1; // 1st gear if (y &lt; HS_YAXIS_246) _gear_ = 2; // 2nd gear } else if (x &gt; HS_XAXIS_56) // Shifter on the right? { if (y &gt; HS_YAXIS_135) _gear_ = 5; // 5th gear if (y &lt; HS_YAXIS_246) _gear_ = 6; // 6th gear } else // Shifter is in the middle { if (y &gt; HS_YAXIS_135) _gear_ = 3; // 3rd gear if (y &lt; HS_YAXIS_246) _gear_ = 4; // 4th gear } } } if (gear == 6 &amp;&amp; _isreverse == 1) // Reverse gear is allowed only on 6th gear position { b[DI_REVERSE] = 1; _gear_ = 8; } if (_gear_ != gear) { gear = _gear_; desactivar(); Joystick.setButton(gear - 1, HIGH); } } delay(50);}void desactivar(){ // Depress virtual button for current gear for (int i = 0; i &lt;= 10; i++) Joystick.setButton(i, LOW);} 만약 페달의 최소 위치와 최대 위치등을 조절하려면, 113~115 라인의 앞에 숫자 2가지 부분을 잘 조절하면 된다. 조절은 107~111 라인의 숫자를 기반으로 누르지 않은 상태와 끝까지 누른 상태의 적당한 값을 넣어서 맞추면 된다. 게임에서의 테스트이렇게 연결하게 되면 문제점이 있다. 게임에서는 2가지의 레이싱 장비가 인식될 것이고, 휠과 쉬프터, 페달의 세팅을 게임마다 수동으로 지정을 해 주어야 한다. 아세토코르사 및 프로젝트카스2, 호라이즌4 에서는 조금 불편하지만 설정을 하게 되면 정상적으로 동작하는것을 확인했다. 다른 장비에서도 사용 가능할까?이게 가능한 원리를 보면 결국 쉬프터나 페달들이 모두 가변저항의 아날로그 신호값을 통해 수치화를 하고 있는것을 알 수 있다. 요점은 연결에 사용되는 아날로그 신호의 단자를 찾는것일것 같다. 페달쪽 영상을 보면 테스터기를 통해 어떤 단자인지 찾는 부분이 보인다. 이 방법을 참고해서 배선만 잘 딴다면 어떤 장비던 사실 모두 적용이 가능하리라 본다. 문제는 c++ 을 조금 다룰 줄 알아야 자기가 원하는 동작을 하도록 구현이 가능한 것… 내가 이렇게 사용하게 된 계기는 결국 다른 페달과 쉬프터를 아직 구하지 못했기 때문이지만, 누군가에게는 이 글이 도움이 될 것 같아 남겨둔다.","link":"/arduino-logitech-diy/"},{"title":"백준 문제 풀이 - 14499","text":"14499 주사위 굴리기 문제 내가 푼 로직객체지향적으로 풀어보기로 결정하였다.먼저 주사위 클래스를 만들고, 해당 클래스에는 주사위의 상태와 돌리는 메서드를 정의했다.또 다른 클래스로 지도 클래스를 만들었는데, 해당 지도 클래스는 전체 지도와 주사위의 현위치를 저장하고 있다.방향을 입력받아 해당 방향으로 이동 가능한지 확인하는 메서드와 실제로 이동하는 메서드를 구현했다. 이후 메인에서 이동하는 명령어를 입력받아, 해당 위치로 이동가능한지 확인후 주사위의 위치를 옮기고, 주사위도 굴린다.그 후, 바닥의 값을 판단하여 주사위 값을 바닥에 복사할지, 바닥의 값을 주사위에 복사할지 판단하여 실행한다. 고생정말 별거 아니지만 문제를 제대로 읽지 않아 문제가 발생하였다.입력으로 오는 순서가 X Y 순서가 아닌 Y X 순서로 들어온다.그래서 처음에 배열 인덱스 관련된 익셉션이 떳고, 이를 해결하였더니 로컬에서 모두 정상적으로 잘 돌아갔다.백준에 제출을 해 보았는데 틀렸다고 나왔다.2시간이나 모든 코드를 뒤져보았는데 틀린곳이 없었다.. 분명 잘돌아가야 하는데?나중에 알고보니.. 시작하는 주사위의 좌표가 주어진 3개의 예제에서는 모두 (0, 0) (1, 1) 과 같이 동일한 예제여서 문제가 없었던 것이었다.내가 실수로 배열을 접근하는데 있어서 [x][y] 로 접근을 해버린 것이다. 배열은 [y][x]로 접근해야한다.지난번에도 비슷한 실수를 했던것 같은데 또 이런 실수를 반복하게 되었다.그래서 다시는 이런 일이 생기지 않도록 이 글을 쓰며 되새기고 있다. ㅠㅠ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;/** * Created by sanghyoun on 2017. 4. 16.. */public class B14499 { public static void main(String[] args) { try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))) { String[] input = br.readLine().split(&quot; &quot;); int ySize = Integer.parseInt(input[0]); int xSize = Integer.parseInt(input[1]); int[] defaultPos = new int[]{Integer.parseInt(input[3]), Integer.parseInt(input[2])}; int commandSize = Integer.parseInt(input[4]); int[][] map = new int[ySize][xSize]; for (int i = 0; i &lt; ySize; i++) { String[] mapInput = br.readLine().split(&quot; &quot;); for (int k = 0; k &lt; xSize; k++) { map[i][k] = Integer.parseInt(mapInput[k]); } } String[] commands = br.readLine().split(&quot; &quot;); /*************** 입력끝 ***************/ Dice dice = new Dice(); DiceMap diceMap = new DiceMap(xSize, ySize, defaultPos[0], defaultPos[1], map); for (int i = 0; i &lt; commandSize; i++) { int comm = Integer.parseInt(commands[i]); if (diceMap.isValid(comm)) { diceMap.move(comm); dice.move(comm); int curNum = diceMap.getCurNum(); if (curNum == 0) { diceMap.setCurNum(dice.getBottom()); } else { dice.setBottom(curNum); diceMap.setCurNum(0); } bw.write(Integer.toString(dice.getUpper())); bw.newLine(); } else { continue; } } return; } catch (Exception e) { e.printStackTrace(); } }}class Dice { private int upper; private int bottom; private int left; private int right; private int up; private int down; public Dice() { upper = 0; bottom = 0; up = 0; left = 0; right = 0; down = 0; } public void move(int direction) { // 우 1 좌 2 위 3 아래 4 int temp; switch (direction) { case 1: // up과 down은 변화없음 temp = bottom; bottom = right; right = upper; upper = left; left = temp; break; case 2: // up과 down 은 변화없음 temp = bottom; bottom = left; left = upper; upper = right; right = temp; break; case 3: // left와 right 변화없음 temp = bottom; bottom = up; up = upper; upper = down; down = temp; break; case 4: // left와 right 변화없음 temp = bottom; bottom = down; down = upper; upper = up; up = temp; break; } } public int getUpper() { return upper; } public int getBottom() { return bottom; } public void setBottom(int num) { this.bottom = num; }}class DiceMap { private int maxXpos; private int maxYpos; private int xPos; private int yPos; private int[][] map; public DiceMap(int x, int y, int curX, int curY, int[][] map) { this.maxXpos = x - 1; this.maxYpos = y - 1; this.xPos = curX; this.yPos = curY; this.map = map; } public boolean isValid(int direction) { // 우 1 좌 2 위 3 아래 4 switch (direction) { case 1: return xPos + 1 &lt;= maxXpos; case 2: return xPos - 1 &gt;= 0; case 3: return yPos - 1 &gt;= 0; case 4: return yPos + 1 &lt;= maxYpos; } return false; } public void move(int direction) { switch (direction) { case 1: xPos++; break; case 2: xPos--; break; case 3: yPos--; break; case 4: yPos++; break; } } public int getCurNum() { return map[yPos][xPos]; } public void setCurNum(int num) { map[yPos][xPos] = num; }}","link":"/B14499/"},{"title":"백준 문제 풀이 - 1697","text":"1697 숨바꼭질 문제 그냥 여담알고리즘 공부를 시작한지 얼마 되지 않아서 문제를 보고 고민을 하였다.어떤 방법으로 접근을 해야 할 지 몰랐기 때문이다.무식하게 풀어 보려고 했는데 뭔가 효율적인건 없을까 생각을 하다가 밑에 알고리즘 분류를 보니백트래킹 과 DFS , BFS 가 보여서 아차 하며 깨닫게 되었다.이런 개념 조차 아직 제대로 잡히지 않은 나에게 첫 문제이다. 자바로 만든 백준 제출의 첫 경험처음 완성을 하고 백준에 제출을 했다.바로 틀렸습니다가 나왔다. 분명 로직이 틀린게 없다고 생각했고, 뭐가 문제일까 하고 한참 삽질을 했다.그래서 방법을 바꿔서 풀었다.그래도 오류가 났다. 분명히 결과값은 같은데… 원인 분석에 들어갔다.문제는 아주 간단했다. 패키지로 알고리즘 문제들을 다 모아놨었는데 그 패키지 선언문이 문제였다.해당 줄을 삭제하자 아까와는 다르게 채점중.. 이란 단어도 떳다 ㅠㅠ덕분에 문제를 좀 더 효율적으로 풀게 되긴 하였다. 나중에 첫 제출했던 코드도 패키지를 빼자 채점이 제대로 되었는데, 시간초과가 떳다.첫 제출했던 코드는 이미 방문했던 위치를 검사하지 않게 짰었는데, 그것 때문에 시간이 오래 걸린것 같다. 어쨋든 그리하여 지금은 제대로 잘 풀었다. 내가 푼 로직조건에 맞는 위치만큼 배열을 생성한다.방문하지 않았다는것을 알리기 위해 배열을 -1로 채운다.큐에 시작위치를 넣고 초기화를 한다.큐에서 꺼낸 위치가 목적지와 같을때까지 아래를 반복한다.(배열에 접근하는 인자가 위치값이다)이동할 위치가 조건내이고, 아직 방문하지 않았다면 현위치의 시간값 +1을 하여 해당 위치의 시간값에 넣는다. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.Arrays;import java.util.LinkedList;import java.util.Queue;/** * Created by sanghyoun on 2017. 4. 9.. */public class B1697 { public static void main(String[] args) { try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))) { String[] input = br.readLine().split(&quot; &quot;); int start = Integer.parseInt(input[0]); int end = Integer.parseInt(input[1]); int ret = bfs(start,end); bw.write(Integer.toString(ret)); } catch (Exception e) { e.printStackTrace(); } } public static int bfs(int start, int end) { int[] time = new int[100001]; Arrays.fill(time, -1); Queue&lt;Integer&gt; que = new LinkedList&lt;Integer&gt;(); que.add(start); time[start] = 0; while (!que.isEmpty()) { int curLocation = que.remove(); if (curLocation == end) { return time[curLocation]; } if ((curLocation - 1 &gt;= 0) &amp;&amp; (time[curLocation - 1] == -1)) { time[curLocation - 1] = time[curLocation] + 1; que.add(curLocation - 1); } if ((curLocation + 1 &lt;= 100000) &amp;&amp; (time[curLocation + 1] == -1)) { time[curLocation + 1] = time[curLocation] + 1; que.add(curLocation + 1); } if ((curLocation * 2 &lt;= 100000) &amp;&amp; (time[curLocation * 2] == -1)) { time[curLocation * 2] = time[curLocation] + 1; que.add(curLocation * 2); } } return -1; }}","link":"/B1697/"},{"title":"카이 호스트만의 코어 자바8 2장 연습문제 일부 코드","text":"연습문제 답일부 중요하거나 풀어보고 싶은 문제만 풀었으며, 그에 대한 나의 코드를 공개한다. 9번 문제연비가 설정되고 기름을 넣고 이동하는 자동차 클래스를 작성하는것.연습문제를 기반으로 나의 생각을 조금 덧붙여 코드를 작성하였다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Created by sanghyoun on 2017. 3. 21.. */public class Ch2_9 { public static void main(String[] args) { Car car1 = new Car(); car1.fillOil(10); car1.drive(50); car1.setKmPliter(20); car1.drive(100); car1.drive(100); car1.fillOil(5); car1.drive(100); System.out.println(String.format(&quot;Current Efficiency : %.1f &quot;, car1.getEfficiency() )); }}class Car { private double oilTank; private double kmPliter; private double usedOil; private int startPoint; private int currentPoint; public Car() { this.oilTank = 0; this.kmPliter = 10; this.startPoint = 0; this.currentPoint = this.startPoint; } public void setKmPliter(double num) { this.kmPliter = num; } public double fillOil(double liter) { return this.oilTank += liter; } public int drive(int distance) { double oilNeed = distance / this.kmPliter; if (oilNeed &lt;= this.oilTank) { this.oilTank -= oilNeed; this.usedOil += oilNeed; return this.currentPoint += distance; } else { double moveableDistance = this.oilTank * this.kmPliter; oilNeed = moveableDistance / this.kmPliter; this.oilTank -= oilNeed; this.usedOil += oilNeed; System.out.println(&quot;More Oil Need : &quot; + (distance - moveableDistance) / this.kmPliter); return this.currentPoint += moveableDistance; } } public double getEfficiency() { return this.currentPoint / this.usedOil; }}","link":"/core_java_prac_ch02/"},{"title":"Mailgun 을 이용하여 개인 도메인 메일 서버 구축하기","text":"여러 레퍼런스들을 참고하여 진행하였지만, 가장 잘 정리된곳은 이곳 이다. Mailgun 가입하기Mailgun 서비스는, 기존에 존재하는 도메인을 이용해 메일 발송과 수신을 할 수 있게 해주는 서비스이다.발송은 월 1만건까지 가능하며, 그 이상 되면 과금이 되는 형식이다.또는 서비스 플랜에 가입하여 사용 가능하다.수신의 경우 특정 메일로 포워딩을 해주는 서비스를 할 수 있다.따라서 개인 이메일로 포워딩을 시켜 편하게 이메일을 받아 볼 수 있다. https://www.mailgun.com/ 공식 홈페이지에서 회원 가입을 한다. 가입을 할 때 카드 정보를 입력하지 않으면, 나중에 이메일을 보낼 경우 Free accounts are for test purposes only. Please upgrade or add the address to authorized recipients in Account Settings 라는 메세지가 뜨게 된다.정보를 입력하지 않고 진행하고 테스트를 마친 후 정보를 입력해도 된다. 정보를 모두 입력하고 다음 단계로 넘어가면 이메일 인증을 거치며, 받은 이메일에서 링크를 클릭하면 SMS 인증을 하게 된다. 도메인 등록하기모든것을 마치면 이제 도메인을 등록 할 차례이다.로그인 하면 아래의 Add New Domain 버튼을 눌러주자. 이후 도메인을 입력하는 창이 나오는데, abc.com 이라면 똑같이 적어주면 된다.그런데 서브도메인을 쓰기를 권장한다.서브도메인을 쓰면 @mail.abc.com 라는 주소로 생성이 되는 것이고, 쓰지 않는다면 @abc.com 으로 생성이 된다.나같은경우 서브 도메인이 없이 등록을 하였다. 이후에는 각종 설정법들이 나온다.도메인을 인증하는 과정인데, 영어를 읽을 수 있으면 그냥 하란대로 하면 되는데 대충 설명하겠다.개인의 도메인 네임 서버 셋팅으로 가서, TXT 타입으로 정보를 추가해주고, MX타입으로 메일서버를 등록해주고, CNAME 을 등록하는 것이다.모든 정보를 복사 붙여넣기로 세팅을 하고, 도메인 네임서버가 적용되기를 조금 기다리자.아래와 같은 사진에서 Cehck DNS Records Now 를 누르자 적용이 제대로 되면, 아래와 같이 모두 초록색으로 잘 뜬다. 메일 보내기 테스트메일 보내는법은 여러가지가 있는데, 나는 OSX 에서 가장 간편한 curl 로 보내보겠다.공식홈페이지 문서를 보면, 아래와 같이 보내면 된다고 한다. 1234567curl -s --user 'api:YOUR_API_KEY' \\ https://api.mailgun.net/v3/YOUR_DOMAIN_NAME/messages \\ -F from='Excited User &lt;mailgun@YOUR_DOMAIN_NAME&gt;' \\ -F to=YOU@YOUR_DOMAIN_NAME \\ -F to=bar@example.com \\ -F subject='Hello' \\ -F text='Testing some Mailgun awesomness!' YOUR_API_KEY 부분과, URL을 도메인 설정에서 찾아 바꿔주고,from, to, subject, text 부분을 본인에게 맞게 설정하면 된다.정상적으로 보내졌다면 아래와 같은 메세지가 뜬다. 1234{ &quot;id&quot;: &quot;&lt;해쉬값@abc.com&gt;&quot;, &quot;message&quot;: &quot;Queued. Thank you.&quot;} 그런데 큐에 들어간 뒤에도 꽤 시간이 지나야 메일이 발송된다… 지금만 그런 것일까?.. 도메인으로 이메일 받아보기메뉴중에 Routes 로 들어간다. 거기서 Create Route 메뉴를 누르고Expression Type : Catch All (모든 메일을 포워딩한다)Actions : Forward (체크박스에 체크하고 아래에 받아볼 메일 주소를 쓰면 된다) 이렇게만 설정을 한 후 적용을 시키면 정상적으로 작동한다.다른 옵션을 쓰려면 다르게 해도 된다. 이후 @abc.com 으로 오는 모든 메일은 위에서 설정한 메일 주소로 모두 포워딩 되어 온다.","link":"/mailgun/"},{"title":"첫 Markdown Blog 포스팅","text":"나는 기존에 블로그를 하긴 하였다.바쁘다, 귀찮다는 핑계로 제대로 된 업데이트를 하지 않았지만 말이다.기존 블로그 주소 : http://hinco.tistory.com/ 포스팅된 글은 11개밖에 없지만 하루 평균 50명의 방문자를 꾸준히 찍어주고 있다. 기존 블로그를 폐쇄를 하진 않겠지만 앞으로 새로운 포스트는 마크다운 언어로 작성하여 발행 할 예정이다.현재는 Hexo 블로그를 쓰고 있지만, 마크다운 언어 특성상 .md 파일만 있다면 백업이 용이하기 때문에 언제 다른 블로그로 떠나갈지 모른다. 이 포스트는 나의 시작을 알림과 동시에, 마크다운에 적응하기 위한 첫 글이다. 1console.log(&quot;테스트용 코드 주석!&quot;); 마크다운 규칙을 사진과 함께 잘 정리해준 다른 글을 남겨두겠다. 기술 글쓰기 1 - Markdown과 친해지기 http://www.hakawati.co.kr/405 앞으로 자주 방문하게 될 사이트 인 것 같다.","link":"/first-post/"},{"title":"XPEnology에 Docker를 이용하여 TVHeadend 설정하기","text":"예전에 시도해보았던 TVHeadend 를 다시 이용해보기로 했다. 환경 설정TVHeadend 를 이용하기 위해서는, 기본적으로 네트워크가 공인 IP를 받아야 한다.또는 공유기를 사용중이라면, 공유기 내에 IGMP 서비스나 IPTV 서비스 등을 이용하여 리눅스가 할당받은 IP에 신호를 넘겨줘야한다. Docker를 통하여 설치하기DSM에 네이티브로 설치를 할 수도 있지만, 개인적으로 Docker 를 이용하는것을 좋아한다.이미지는 다운로드수가 가장 많고 업데이트가 활발한 linuxserver/tvheadend/ 를 사용했다.Docker 컨테이너를 만드는 명령어는 아래와 같이 입력하면 된다. docker create --name=tvheadend --net=host linuxserver/tvheadend:release-4.2 공식 Document 를 참고하여, 나의 설정에 맞는 컨테이너 생성 코드이다.이름은 tvheadend로, 네트워크는 호스트와 같은 네트워크 사용하는것이다. (이 옵션이 굉장히 중요하다)이렇게 컨테이너를 생성하고 start 시켜준다. 이후 http://[DSM URL]:9981 으로 접속을 하면 메인 페이지가 뜬다. TVHeadend에 채널 등록하기우선 방송 IP 리스트가 필요하다.이 부분은 민감한 사항이므로, 구글링을 통해 직접 해결하길 바란다.IP 리스트가 있다면, M3U 생성기를 이용하여 이쁜 M3U 파일을 만들어주자. M3U 파일이 있다면, 이 파일을 DSM안에 Web Station 을 통해 웹으로 접속 가능하도록 만들어 준다.이후 내용은 이곳을 참고하여 진행하면 된다. TVHeadend 홈페이지 안에서 DVB Inputs 메뉴에서 Networks 안에 새로운 네트워크를 등록한다.IPTV Automatic Network 로 선택하고, Maximum # input streams 는 5정도,URL은 아까 올렸던 M3U 파일의 웹 경로를 써주면 된다.여기서 M3U 경로는 외부 아이피가 아닌 내부 아이피로 써줘야 한다. 이거 몰라서 1시간 보냄그러면 Muxes 에 채널들이 보인다. 스캔이 바로 시작되는데 끝날때까지 기다린다. IP 주소가 정확한데, 스캔결과가 확인 으로 뜨지 않는다면 네트워크 문제가 있는 것이다.이경우에는 네트워크 구성을 다시 살펴봐야 한다. 이후 서비스 탭으로 옮겨가서 서비스 매핑 버튼을 누르고, 모든 서비스 매핑을 실행한다.같은이름을 병합시킨다는 내용의 체크박스를 누르고 실행하는것이 좋다.그래야 같은 채널 서비스는 중복되어 저장되지 않는다. 채널 탭으로 이동하면 모든 서비스들이 제대로 나온것을 볼 수 있고, 가장 왼쪽에 재생 버튼이 있다.아무 채널이나 눌러서 재생을 해서 정상적으로 재생된다면 끝난 것이다. EPG 등록하기EPG를 등록하기 위해서는 우선 EPG2XMl 이라는것을 설치해야한다.https://github.com/sungpyohong/epg2xml 에서 받으면 되는데,작성자분이 바뀐것인지 링크로 들어가면 https://github.com/wonipapa/epg2xml 이곳으로 가진다.이곳에서 설명하는대로 실행하면 되는데, 주기적으로 epg를 갱신해야 하므로 .py 를 이용하는 방법이 좋다.자세한 진행 사항은 https://x86.co.kr/clubs/1399085를 참조하자. 사용하기이제는 TVHeadend 서비스는 정상적으로 설치되었다.클라이언트 프로그램들을 이용하여 서비스를 사용하면 된다.","link":"/nas-TVHeadend-setting/"},{"title":"ESXi 위에 Ubuntu server 16.04 설치기","text":"기존에는 DSM 위에서 각종 서버들을 구동하였다.서버 개발을 본격적으로 시작하는 지금, 직접 우분투 서버를 처음부터 구성하고 실제 프로젝트에 사용하기 위해 세팅을 할 것이다.기존에 AWS EC2나 다른 클라우드 서버 등을 사용하였지만, 직접 구축해본다는것은 또 다른 느낌이다.시작하겠다!! Ubuntu Server 이미지 구하기https://www.ubuntu.com/download/server위 주소에서 우분투를 다운받아 ESXi의 Datastore에 업로드한다. ESXi 세팅하기새로운 VM을 생성한다.Ubuntu Linux 64비트 설정으로 생성을 하였고, CPU는 1소켓, 소켓당 코어수는 1로 설정하였다.찾아보니 CPU와 소켓당 코어수는 직접 설정해도 되나 VMWare 측의 권장사항은 1소켓 1코어로 해도 된다고 한다.코어제한이 걸린 라이센스 때문에 이 옵션이 존재하는것 같다.리눅스는 제한이 없기 때문에 선택은 자유이다.내 서버에는 아직 SSD가 없기 때문에 HDD 를 100기가 할당하고 메모리는 3기가를 주었다. Ubuntu 설치하기구글에 우분투 설치 라고만 쳐도 좋은 튜토리얼들이 많이 있는것 같다.하지만 튜토리얼을 보지 않더라도 그냥 쭉쭉 읽어보면 어렵지 않게 설치가 가능했다.Local 설정은 US 그대로 하였고, 키보드 레이아웃도 US로 하였다.Region 설정만 Asia/Seoul 로 진행하였다.서버 설치 완료 후, 모든 패키지를 최신버전으로 업데이트 하였다. 12$ sudo apt-get update$ sudo apt-get upgrade openssh-server 설치설치 도중 추가적인 패키지를 설치하는 페이지가 있는데, 엔터를 잘못 눌러 그냥 진행이 되어버렸다.그래서 openssh-server 를 따로 설치하였다.이곳 을 참조하였다. 123456$ sudo apt-get install openssh-server$ netstat -ntlActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:22 0.0.0.0:* LISTENtcp6 0 0 :::22 :::* LISTEN 계정 설정하기우분투 설치 중, 실제 유저 이름을 적으라 해서 정말 내 이름을 적었더니 그것이 유저네임이 되어버렸다.그래서 다른 계정을 만들기 위해 유저를 만들었다.이곳 을 참조하였다. 1234$ useradd [유저이름]$ passwd [유저이름]Changing password for user [유저이름]New UNIX password: 만들고 해당 유저로 로그인해서 진행중, sudo 명령어를 치니 에러가 났다.구글링을 해본 결과 이곳 에서 원인을 알 수 있었다.sudo명령어를 칠 수 있는 유저들을 관리하는 /etc/sudoers 에 유저를 추가해야 했다.블로그를 참고하여 1$ visudo -f /etc/sudoers 명령어를 치고 새로 만든 내 유저를 추가하려고 보니, 내용중 아래와 같은 부분이 있었다. 12# Members of the admin group may gain root privileges%admin ALL=(ALL) ALL admin 그룹에 속한 유저는 모두 sudo 를 쓸 수 있다는 것이었다.그래서 기존에 내가 만들었던 유저를 admin 그룹에 속하도록 하였다.먼저 admin 이라는 그룹을 생성하고, 기존에 존재하던 유저를 해당 그룹 소속으로 바꿨다. 12$ groupadd admin$ usermod -g admin [유저이름] 그리고 나서 해당 유저로 sudo 명령어가 정상적으로 작동되었다. Ubuntu에 Docker 설치하기나같은경우, Ubuntu에 Docker를 설치하여 각종 프로젝트에 쓸 예정이다.찾아보니 설치법은 두가지가 있었다.첫번째로는 자동 설치이다. 1$ curl -s https://get.docker.io/ | sudo sh 이 명령어로 설치하면 알아서 해당 OS에 맞는 버전을 설치하는것 같다.하지만 난 패키지를 통해 설치하였다. 1$ sudo apt-get install docker.io 설치를 다 하였지만, 도커는 기본적으로 root 권한이 필요하다.따라서 이곳 을 참조하여 권한 설정을 하였다. 12$ sudo usermod -aG docker $USER$ sudo service docker restart 이후 유저를 재 로그인 하면 sudo 명령어 없이 해당 유저는 docker 명령어를 쓸 수 있다.","link":"/ubuntu_first_settings/"},{"title":"개인 서버에 K8S 환경 구축하기","text":"환경 구성가상화 Hypervisor ESXi 위에 3대의 Ubuntu 서버를 구성했다. Bastion &amp; Master * 1 EA Node * 2 EA 위 Bastion &amp; Master 서버에는 K3S Server 로 구동, Node 에는 K3S Agent 로 구성되어있다. NPM 은 Node Package Manager 가 아니고 Nginx Proxy Manager 이다.ESXi 위에 Ubuntu 말고도 개인용으로 사용하는 NAS 가 있어서, Revers proxy 를 설정하기 위해 구성하였다.직접 Nginx 를 설정할수도 있지만 간단하게 설정이 가능해서 적용을 했는데 꽤 괜찮은것 같아 계속 사용하고 있다. K3S 설치우선 Ubuntu server 20.04 이미지로 설치한 서버에 Master 용도 하나, Node 용도 2개 설치를 진행했다. Server(Master) 설치K3S Server 는 생각보다 간단하다.K3S Install guide 에 나오는 설치 방법으로 진행하면 바로 Server 모드로 설치가 된다. 1curl -sfL https://get.k3s.io | sh - 설치 이후 Agent 들에서 Cluster 에 접근하기 위한 Token 정보를 얻어야 한다. 1sudo cat /var/lib/rancher/k3s/server/token 여기서 나온 값은 아래 Agent 설치 단계에서 사용해야 한다. Agent(Node) 설치Node 설치는 위와 같은 스크립트를 사용하지만 환경변수를 몇개 입력한 채로 실행해야 한다. K3S_URL : Server 의 API URL (https://{IP}:6443) K3S_TOKEN : 위 단계에서 복사했던 Server 의 Token 값1curl -sfL https://get.k3s.io | K3S_URL={URL} K3S_TOKEN={TOKEN} sh - 이후 Server 쪽에서 Node 를 조회해보면 정상적으로 잡혀있는게 보인다.1kubectl get node ArgoCD 설치기존엔 manifest 파일을 git 에 저장하고, 관련 리소스를 bastion 서버에 두고 apply 하는 방식으로 운영을 했었다.이번엔 Gitops 를 한번 적용해보고자, ArgoCD 의 적용을 생각하고 있어서 설치를 진행했다. ArgoCD 는 K8S 내에 설치를 했다. 12kubectl create namespace argocdkubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml 설치 후 접근을 위한 ingress 가 별도로 있지 않아서 Service 에서 type 을 Node Port 로 변경하고 포트를 지정했다.그리고 NPM 에서 해당 포트를 도메인과 연결해서 proxy 하도록 설정했다. UI 에 정상 접근되는것을 확인한 뒤, 로그인을 위한 Password 를 얻어 비밀번호를 변경했다.메뉴얼상 Secret 에 있는 password 는 단순한 initialize 과정에서만 사용되는 값으로, 변경 이후 삭제하는게 좋다고 하여 삭제를 진행했다. 12kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;{.data.password}&quot; | base64 -dkubectl -n argocd delete secret argocd-initial-admin-secret K8S Manifest 생성을 위한 cdk8s 구성Manifest 를 직접 구성하는것도 생각을 해봤지만, 오랫동안 손놓았던 Typescript 도 익숙해질 겸, 최신 기술도 써볼 겸 cdk8s 사용 하기로 했다.Install guide 를 보니 npm (여기서는 Node Package Manager…) 을 통해 global 설치를 하는데, 최대한 global 설치를 하지 않는 나는 그냥 npx 를 사용했다. 1npx cdk8s-cli init typescript-app ArgoCD 를 연동하기 위해선 Repository 가 하나 필요한데, cdk8s 를 설정한 Repository 에서 빌드를 하게 되면 dist 폴더가 생기게 된다.나는 복잡한 구성 없이 해당 폴더를 바로 사용하기로하여, .gitignore 를 수정하여 push 를 진행했다. ArgoCD 설정Repository 연결Settings &gt; Repository 에서 Repository 설정을 해야한다.나는 Github HTTP 방식으로 연결을 했다.Github 에서 Access Token 을 ArgoCD 용으로 하나 발급받아 연결을 했다. 연결 후 ArgoCD 에서 New App 을 누르고 필요한 정보를 입력했다. App 생성New APP 을 통해 이름을 작성하고, 프로젝트는 default 로 놓았다.Destination 쪽 Cluster 는 같은 클러스터를 대상으로 하기 때문에, 기본적으로 설정이 가능하다.Namespace 는 따로 설정을 안해봤는데, 그럴 경우 일부 동작이 좀 이상하게 있는 부분이 있어 test 로 지정했다. 이후로 cdk8s 에서 synth 를 하고 나온 dist 폴더를 commit 하니 ArgoCD 에서 이를 인식하고 sync 하는 과정이 생겼다.일부 sync 과정 중에서 제대로 적용이 되지 않는 등의 문제가 있는데이 글과는 별개의 내용이라 다른 포스트로 작성을 하는게 좋을것 같다.","link":"/setting-k8s-infra-into-personal-server/"},{"title":"카이 호스트만의 코어 자바8 1장 연습문제 일부 코드","text":"연습문제 답일부 중요하거나 풀어보고 싶은 문제만 풀었으며, 그에 대한 나의 코드를 공개한다. 6번 문제재귀(Recursion) 방식과 동적 계획법(Dynamic Programing) 방식으로 풀었다.한 가지 방법으로 풀어도 되지만, 둘 다 공부 할 겸 두 방식 모두 풀었다. 123456789101112131415161718192021222324252627282930313233343536373839404142import java.math.BigInteger;/** * Created by sanghyoun on 2017. 3. 14.. */ public class Ch1_6 { public static BigInteger[] dp = new BigInteger[1000]; public static void main(String[] args) { Scanner input = new Scanner(System.in); // 0 이 입력 될 때까지 입력 무한 반복. while (true) { System.out.print(&quot;Tpye number (max num = 1000) : &quot;); int max = Integer.parseInt(input.nextLine()); if (max == 0) { System.out.println(&quot;End of Factorial.&quot;); break; } // 결과값 출력 System.out.println(factorialDP(max)); } } // 일반적인 Recursive factorial 계산 public static BigInteger factorial(int num) { if (num == 1) { return new BigInteger(&quot;1&quot;); } else { return factorial(num - 1).multiply(new BigInteger(Integer.toString(num))); } } // Dynamic Programing 방식 factorial 계산 public static BigInteger factorialDP(int num) { if (num == 1) { Ch1_6.dp[num] = new BigInteger(&quot;1&quot;); } else if (Ch1_6.dp[num] == null) { Ch1_6.dp[num] = Ch1_6.factorialDP(num - 1).multiply(new BigInteger(Integer.toString(num))); } return Ch1_6.dp[num]; }} 13번 문제문제의 해석이 이상하게 된 것인지 제대로 이해가 가지 않았다.일단 내가 이해 한 바는 아래와 같다. 1~49로 채워진 배열 리스트에서 임의의 인덱스에 있는 숫자를 뺀다.6번 반복 후, 없어진 수를 찾아 출력한다. 이렇게 이해 하고 문제를 풀었다.디버깅 용으로 출력도 만듬 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Random;/** * Created by sanghyoun on 2017. 3. 14.. */public class Ch1_13 { public static void main(String[] args) { ArrayList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); for(int i=0; i&lt;49; i++) { nums.add(i+1); } Random generator = new Random(); System.out.print(&quot;Removed [ &quot;); for(int i=0; i&lt;6; i++) { int num = generator.nextInt(48-i); System.out.print(nums.get(num) + &quot; &quot;); nums.remove(num); } System.out.println(&quot;]&quot;); int count=1; System.out.print(&quot;Result [ &quot;); for(int i=0; i&lt;43; i++) { if(nums.get(i) == count) { count++; } else { System.out.print(count + &quot; &quot;); count += 2; } } System.out.println(&quot;]&quot;); }} 14번 문제역시 문제가 이상 한 것 같다. MagicSquare 라는데 마방진 이다.마방진은 가로, 세로, 대각선 각각의 합이 모두 같아야 하는데, 주어진 예제에서는 대각선이 일치하지 않았다.그래서 구글링을 통해 다른 예제를 가져왔다. 120 103 86 69 52 35 18 1 224 207 190 173 156 139 122121 119 102 85 68 51 34 17 15 223 206 189 172 155 138137 135 118 101 84 67 50 33 16 14 222 205 188 171 154153 136 134 117 100 83 66 49 32 30 13 221 204 187 170169 152 150 133 116 99 82 65 48 31 29 12 220 203 186185 168 151 149 132 115 98 81 64 47 45 28 11 219 202201 184 167 165 148 131 114 97 80 63 46 44 27 10 218217 200 183 166 164 147 130 113 96 79 62 60 43 26 98 216 199 182 180 163 146 129 112 95 78 61 59 42 2524 7 215 198 181 179 162 145 128 111 94 77 75 58 4140 23 6 214 197 195 178 161 144 127 110 93 76 74 5756 39 22 5 213 196 194 177 160 143 126 109 92 90 7372 55 38 21 4 212 210 193 176 159 142 125 108 91 8988 71 54 37 20 3 211 209 192 175 158 141 124 107 105104 87 70 53 36 19 2 225 208 191 174 157 140 123 106 당연히 이 예제의 값은 Yes가 나옴.또다른 예제 11 18 25 2 910 12 19 21 34 6 13 20 2223 5 7 14 1617 24 1 8 15 2차원 ArrayList를 사용했다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.ArrayList;import java.util.Scanner;/** * Created by sanghyoun on 2017. 3. 15.. */public class Ch1_14 { public static void main(String[] args) { Scanner scan = new Scanner(System.in); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; dim2num = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) { String line = scan.nextLine(); if (&quot;&quot;.equals(line)) { break; } String[] nums = line.split(&quot; &quot;); ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (String num : nums) { temp.add(Integer.parseInt(num)); } dim2num.add(temp); } if (magicSquare(dim2num)) { System.out.println(&quot;YES&quot;); } else { System.out.println(&quot;NO&quot;); } } public static boolean magicSquare(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arr) { int sum=0; // 동남쪽 대각선 합 구하기 for (int i=0; i &lt; arr.size(); i++) { sum += arr.get(i).get(i); } // 동북쪽 대각선 검사 int temp=0; for (int i=arr.size() - 1; i &gt;= 0; i--) { temp += arr.get(i).get(i); } if (sum != temp) { return false; } // 가로 검사 for (ArrayList&lt;Integer&gt; yPos : arr) { temp = 0; for (int i=0; i&lt;yPos.size(); i++) { temp += yPos.get(i); } if (sum != temp) { return false; } } // 세로 검사 for (int i=0; i &lt; arr.size(); i++) { temp = 0; for (ArrayList&lt;Integer&gt; xPos : arr) { temp += xPos.get(i); } if (sum != temp) { return false; } } return true; }} 15번 문제파스칼 삼각형 이다.문제에서는 2차원 ArrayList 에 작성 n의 파스칼 삼각형을 작성하라고 나와있어서따로 입력을 받고 해당 숫자만큼 반복하게 만들었다.확인을 위한 출력 코드까지 포함하고 있다. 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.Scanner;/** * Created by sanghyoun on 2017. 3. 20.. */public class Ch1_15 { public static void main(String[] args) { System.out.print(&quot;Type number : &quot;); Scanner input = new Scanner(System.in); int num = Integer.parseInt(input.nextLine()); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; tri = new ArrayList&lt;&gt;(); pascal(num, tri); for(ArrayList&lt;Integer&gt; first : tri) { System.out.print(&quot;[ &quot;); for(int tmp : first) { System.out.print(tmp + &quot; &quot;); } System.out.println(&quot;]&quot;); } } public static void pascal(int num, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; tri) { for (int i = 0; i &lt; num; i++) { ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); // 가장 앞에 있는 1을 추가함 temp.add(1); // 각 n번째의 숫자를 위의 배열에서 읽어온 다음 더해서 저장. for (int k = 1; k &lt; i; k++) { int sum = tri.get(i-1).get(k - 1) + tri.get(i-1).get(k); temp.add(sum); } // 가장 뒤에 있는 1을 추가함 if (i != 0) { temp.add(1); } tri.add(temp); } }}","link":"/core_java_prac_ch01/"}],"tags":[{"name":"Game","slug":"Game","link":"/tags/Game/"},{"name":"Diy","slug":"Diy","link":"/tags/Diy/"},{"name":"Arduino","slug":"Arduino","link":"/tags/Arduino/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"코어 자바8","slug":"코어-자바8","link":"/tags/%EC%BD%94%EC%96%B4-%EC%9E%90%EB%B0%948/"},{"name":"Mailgun","slug":"Mailgun","link":"/tags/Mailgun/"},{"name":"SMTP","slug":"SMTP","link":"/tags/SMTP/"},{"name":"도메인","slug":"도메인","link":"/tags/%EB%8F%84%EB%A9%94%EC%9D%B8/"},{"name":"넋두리","slug":"넋두리","link":"/tags/%EB%84%8B%EB%91%90%EB%A6%AC/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"NAS","slug":"NAS","link":"/tags/NAS/"},{"name":"TVHeadend","slug":"TVHeadend","link":"/tags/TVHeadend/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"k3s","slug":"k3s","link":"/tags/k3s/"},{"name":"ArgoCD","slug":"ArgoCD","link":"/tags/ArgoCD/"},{"name":"cdk8s","slug":"cdk8s","link":"/tags/cdk8s/"}],"categories":[{"name":"Game","slug":"Game","link":"/categories/Game/"},{"name":"Dev","slug":"Dev","link":"/categories/Dev/"},{"name":"혼잣말","slug":"혼잣말","link":"/categories/%ED%98%BC%EC%9E%A3%EB%A7%90/"},{"name":"알고리즘","slug":"Dev/알고리즘","link":"/categories/Dev/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"NAS","slug":"NAS","link":"/categories/NAS/"},{"name":"Java","slug":"Dev/Java","link":"/categories/Dev/Java/"},{"name":"환경구축","slug":"Dev/환경구축","link":"/categories/Dev/%ED%99%98%EA%B2%BD%EA%B5%AC%EC%B6%95/"},{"name":"Linux","slug":"Dev/Linux","link":"/categories/Dev/Linux/"},{"name":"DevOps","slug":"Dev/DevOps","link":"/categories/Dev/DevOps/"}]}